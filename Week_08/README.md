算法训练营第08周学习笔记

为什么需要位运算？
1.机器里的数字表示方式和存储格式就是二进制;
2.十进制<——>二进制，通常计算机用十六进制的简短方式表示二进制，一般是用0x之后表示十六进制位开始计数。

位运算符

含义		   运算符					示例
左移			<<				0011 => 0110
右移     	>>				0100 => 0011

具体移位时，分逻辑左移和计算机里的左移。在计算机中左移位时，在最高位已存在的位数不管是1还是零就全都移走，空出来的末尾补零；这个操作过程是整串移动。在实际的计算机中一般是一串32位的二进制，而在现在新式的计算机中是64位二进制。所以在64位计算机一个整型就是64个二进制位。

有四种常用的逻辑运算：

  含义						运算符					示例

 按位或						 |						0011 | 1011 	=> 1011
 按位与						 &						0011 & 1011		=> 0011
 按位取反						 ~						0011 ~			=> 1100
 按位异或（相同为0不同为1）		 ^						0011 ^ 1011  	=> 1000

XOR-异或
异或：也可以用“不进位加法”来理解。

异或操作的一些特点：

x ^ 0 = x
x ^ 1s = ~x 	//1s = ~0				//1s是指全1
x ^ (~x) = 1s
x ^ x = 0
c = a ^ b => a ^ c = b, b ^ c = a 		//交换两个数
a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c 	//associative

指定位置的位运算：
1.将x最右边的n位清零：x & （~0 << n）
2.获取x的第n位值（0或1）：（x >> n）&1
3.获取x的第n位的幂值：x & （1 << n）
4.仅将第n位，置为1：x |（1 << n）
5.仅将第n位，置为0：x & （~（1 << n））
6.将x最高位至第n位清零：x &（（1 << n）-1）

实战位运算要点：
1.判断奇偶					x % 2 == 1 ——> (x & 1) == 1		x % 2 == 0 ——> (x & 1) == 0
2.x >> 1 ——> x/2			x = x/2; ——> mid = (left +right) >> 1;
3.x = x & (x - 1) 			清零最低位的1
4.x & -x => 				得到最低位的1
5.x & ~x =>					0


布隆过滤器（Bloom Filter）实现和原理：
1.巴顿.布隆于1970年提出
2.一个很长的二进制向量（位数组）
3.一系列随机函数（哈希）
4.空间效率和查询效率高
5.有一定的误判率（哈希表是精确匹配）
布隆过滤器是一个占用空间很小、效率很高的随机数据结构，它由一个bit数组和一组哈希算法构成；可用于判断一个元素是否在一个集合中，查询效率很高。（它的时间复杂度一般是O（1）至o（n），最优的情况能逼近于O（1）的）
布隆过滤器添加元素：
将要添加的元素给k个哈希函数
得到对应位数组上的k个位置
将这k个位置设为1
布隆过滤器查询元素：
将要查询的元素给k个哈希函数
得到对应于位数组上的k个位置
如果k个位置有一个为0，则肯定不在集合中
如果k个位置全部为1，则可能在集合中

什么情况下需要布隆过滤器？
字处理软件中，需要检查一个英语单词是否拼写正确；Redis缓存
在FBI，一个嫌疑人的名字是否已经在嫌疑名单上；比特币网络
在网络爬虫里，一个网址是否被访问过；分布式系统（Map-Reduce）——Hadoop、search engine
邮箱的垃圾邮件过滤；评论等的过滤功能。

如何判断一个元素是否存在一个集合中？
1.数组
2.链表
3.树、平衡二叉树、Trie
4.Map（红黑树）
5.哈希表
虽然上面这几种数据结构配合常见的排序、二分搜索可以快速高效的处理绝大部分判断元素是否存在集合中的需求。当集合里面的元素数量足够大，如果有500万条记录甚至1亿条记录呢？这个时候常规的数据结构的问题就凸显出来了。数组、链表、树等数据结构会存储元素的内容，一旦数据量过大，消耗的内存也会呈线性增长，最终达到瓶颈。虽然哈希表的查询效率很高，可以达到O(1)的状况。但是哈希表需要消耗的内存依然很高。
使用哈希表存储一亿个垃圾邮件地址会消耗多少呢？哈希表的做法：首先，哈希函数将一个邮件地址映射成8字节信息指纹；考虑到哈希表存储效率通常小于50%（哈希冲突）；因此消耗的内存为：8*2*1亿字节=1.6G内存，普通计算机对如此大的内存消耗是很难承受的，这个时候布隆过滤器就应运而生。


LRU Cache（Least Recent Use）最近最少使用的缓存：它是用一个哈希表再配合一个双向链表来实现的。
1.两个要素：大小、替换策略；
2.Hash Table + Double LinkedList；
3.O（1）查询，O（1）修改和更新。

排序算法分为比较类排序和非比较类排序
1.比较类排序是通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序；
2.非比较类排序是不通过比较来决定元素间的相对次序，他可以突破基于比较排序的时间下届，以线性时间运行，因此也称为线性时间非比较类排序。

初级排序——O（n^2）
1.选择排序（Selection Sort）：每次找最小值，然后放到待排序数组的起始位置；
2.插入排序（Insertinon Sort）：从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前，找到相应位置并插入；
3.冒泡排序（Bubble Sort）：嵌套循环，每次查看相邻的元素如果逆序，则交换。

高级排序——O（nlogn）
1.快速排序（Quick Sort）：数组取标杆pivot，将小元素放pivot左边，大元素放右侧，然后依次对右边和右边的子数组继续快排，以达到整个序列有序。
注意：正常情况下数组的prepend操作的时间复杂度是O（n），但是可以进行特殊优化到O（1），采用的方式是申请稍大一些的内存空间，然后在数组最开始预留一部分空间，再prepend的操作则是把头下标前移一个位置即可。
2.归并排序（Merge Sort）——分治
a）把长度为n的输入序列分成两个长度为n/2的子序列；
b）对这两个子序列分别采用归并排序；
c）将两个排序好的子序列合并成一个最终的排序序列。
3.堆排序（Heap Sort）——堆插入O（logn），取最大/小值O（1）
a）数组元素依次建立小顶堆；
b）依次取堆顶元素，并删除。

特殊排序——O（n）
1.计数排序（Counting Sort）：要求输入的数据必须是有确定范围的整数，将输入的数据值转化为键存储在额外开辟的数组空间中，然后依次把计数大于1的填充回原数组；
2.桶排序（Bucket Sort）：它的工作原理是假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）；
3.基数排序（Radix Sort）：它是按照低位优先排序，然后收集，再按照高位排序，然后再收集，以此类推，直到最高位，有时候这些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。















