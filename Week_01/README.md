学习笔记:

对数据结构数组、链表和跳表的学习总结

数组（Array）
现在的高级语言对于数组里的元素类型没有严格要求，相对比较多样化，在语言的标准上叫做泛型。任何一个单元类型的元素都可以放进去，底层实现用内存管理器，每当申请数组时计算机就在一片连续的内存地址中开辟一段空间。每一个地址可以直接通过内存管理器进行访问。直接访问就是访问第一个元素或者中间任何一个元素所用的时间复杂度都是一样的，即是常数级O（1）的时间复杂度。
对数组进行增加和删除的操作过程关于插入操作的示例：

							inserting
										
0				A							0						A
1				B							1						B
2				C							2						C
3				E							3						<-	D
4				F							4						E
5				G							5						F
6											6						G

所对应的index分别是0-5，当有一个新元素D要插入到这个数组中时，把原来展位的地址都要向下挪动，把要与之对应的地址让出来，这种操作就不再是常数级的操作了，而是呈线性O（n）的时间复杂度，在最坏的情况下插入到中间位置是需要移动整个数组的下半部分，最好的情况是直接插到末尾，这种情况则是O（1）的时间复杂度。所以操作的平均所用时间复杂度是O(n)的；因为，要移动一半元素原来的位置。
删除操作为：
把其中中间的一个元素移走，然后把与之临近的原来元素的位置往前挪动，然后再把最后一位置为空。比如在Java语言中能唤起垃圾回收机制或者在其他语言中手动管理内存，把这个数组的size减少即可。
在添加修改比较频繁的操作时，对数组操作的时间复杂度会比较高，效率相对低下。这种情况就需要另外一种数据结构了，比如：
链表（Linked List）
链表是为了解决数组在添加删除操作频繁而带来的效率低下问题所产生的数据结构。在链表中，元素定义好之后一般有Value和Next等值，而Next指向下一个元素，将其串在一起就变成了一个类似于数组的一种结构，重点是链表中的每一个元素一般用class来定义，而这个class一般叫做node，里面有两个成员变量，一个成员变量是value，也可以有很多成员变量，也可以是一个类，另一个就是有一个next指针指向它的下一个元素，串在一起就形成了一个链表；如果只有一个next指针叫做单链表，另外，有时还要往前面再指一个就叫它的先前指针是prev/previous，这就形成了一个双向链表，是能往后走又能往前走，它的头指针一般用head表示，尾指针用tail表示，最后一个元素的next指向空，如果tail的指针也可以指回head的话，这种链表就想做循环链表。
在两个元素中插入新元素时：前面元素的next指到新元素的“头部”，新元素为“尾部”指回插入位置之前原来元素所在位置的“头部”，也就是把要插入元素的前继节点的next指针指向新节点，而新节点的next指针指向下一个节点。
在删除操作时：
把它的（当时新增加的然后又要删除这个新增加的元素，这个样的元素被称为target node）前驱节点next删除移动到后继节点的位置即可。这样增加和删除操作就没有引起链表的群移操作，所以链表的这种操作只是常数级的时间复杂度。但是如果想访问链表中间的元素就必须一步一步往后挪，直到挪至中间位置，时间复杂度则呈线性表达。

链表一般操作的时间复杂度										数组一般操作的时间复杂度
prepend			O(1)									prepend 		O(1)
append			O(1)									append			O(1)
lookup			O(n)									lookup			O(1)
insert			O(1)									insert			O(n)
delete			O(1)									delete			O(n)

PS:在正常的情况下数组的prepend的操作时间复杂度是O(n)的，但是可以执行特俗优化到O(1)，采用的方式是申请稍微大一些的内存空间然后去数组最开始预留的一部分空间，prepend的操作则是把头下标前移一个位置。

跳表是为了解决在链表规律连续的状态下通过升唯增加多级索引来用空间换时间的做法，每增加一级索引和两个位置点时，所用的时间就减少一倍，则最后呈现的时间复杂度是O(logn)的表现。

